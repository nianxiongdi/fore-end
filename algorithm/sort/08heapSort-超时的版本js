
// https://blog.csdn.net/qq_30638831/article/details/51502658



/**
  arr是完全二叉树 
  i是父节点
  size 一共有多少个节点 
*/
//此函数是构建堆，从最后一页叶子节点开始遍历，利用递归 
function heapify (arr, i, size) {

  if ((i * 2 + 1) < size) {
    let left = (i<<1) + 1 // 左孩子
    let right = (i<<1) + 2 // 右子数
    let largest = i

    if (left < size && arr[largest] < arr[left]) largest = left
    if (right < size && arr[largest] < arr[right]) largest = right
    
    if (largest != i) {
      [arr[i], arr[largest]] = [arr[largest], arr[i]]
      heapify(arr,largest,size); //改变就递归 
    }
  }

}


/** 
 * 初始堆进行调整 
 * 将a[0..size-1]建成堆 
 * 调整完之后第一个元素是序列的最大的元素 
 * 意思就是把堆有序 
 */
function max_heapfy(arr, size){
	
	let i;
	for(i= (size-1) >> 1; i>=0; i--){
		heapify(arr, i, size);
	}

}


/** 
 * 堆排序算法 
 */
function heapSort(arr) {
  let i;
  for (i = arr.length-1; i>= 0; i--) {
    max_heapfy(arr, i+1);
    [arr[i], arr[0]] = [arr[0], arr[i]]

    // console.log(arr);
  }

  return arr
}


let arr = [3,1,5,2,4,9,6]


console.log(heapSort(arr));