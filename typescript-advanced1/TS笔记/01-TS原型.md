### 1. 为什么要用原型（好处）

原型上所有的方法和属性都可以被构造函数`实际开发原型主要共享方法和所有实例公用引用属性`的实例共享，那么为什么要共享呢？`节省内存空间`

### 2. 没有用原型会有什么问题？

**总结问题**: 所有`QQUser`对象（`QQUser`实例）都有相同的好友属性，好友属性用`commonfriends`表示，所有`QQUser`对象都有相同的`show`方法。但我们发现每一个`QQUser`对象都单独分配一个`commonfriends`属性空间和`show`方法空间。`导致大量空间浪费`

**答案**: 使用原型解决所有实例上的方法，还有所有实例上的共同属性都可以放到原型上定义

### 3. 认识函数 + 原型定义

1. 函数也是对象，当真正执行函数，执行环境`开发时为浏览器或控制台`会为函数分配一个`函数对象变量空间`和`函数对象空间`，函数对象变量用函数名表示，存在`栈空间`，函数对象空间是在`堆`中开辟的一个内存空间，这个空间中有一个默认的 prototype 属性，这个属性是原型对象属性

2. 函数和构造函数的区别

当通过`new 函数()`时，此刻这个函数就是构造函数

3. `定义：`原型[ prototype ]是定义函数有 JS 自动分配给函数的一个可以`被所有构造函数实例对象变量共享`的对象变量

### 4. 如何访问原型对象空间上的属性和方法

1. 构造函数所有实例对象都可以访问型对象空间上的属性和方法`每个实例都有默认的proto属性，这个proto属性指向原型对象空间`

2. 关于`proto__`:new 在创建新对象的时候，会赋予新对象一个属性指向构造函数的`prototype`属性，这个属性就是`proto`

3. 可以直接通过构造函数.prototype 对象属性来访问原型对象空间上的属性和方法

### 5.1 构造函数实例如何访问原型对象空间上的属性和方法

1. 构造函数实例访问一个属性和方法，首先从实例空间中查找`当执行环境执行 new 构造函数()时，构造函数中通过this定义的属性和方法会分配在这个空间中`，如果找到该属性和方法，就停止查找，表示找到了；如果没有找到，就继续在该实例的原型对象空间中去查找该属性和方法`实例中默认的proto对象属性指向原型对象空间`

2. 实例正是借助自身的**proto**对象属性来查找原型对象那个空间中的属性和方法，有点像儿子去找爸爸要他没有的东西`继承`。

### 5.2 增加或修改原型对象的属性或方法后，所有实例对象立即可以访问的到`但创建实例后在覆盖原型除外`

### 5.3 高频面试题：创建实例后在覆盖原型，实例对象无法访问到，为什么

```javascript
/* ----------- 高频面试题：创建实例后在覆盖原型，实例对象无法访问到，为什么 ------------- */
// 给构造函数的原型重新赋值
QQUser.prototype = {
  commonfriends: ["海草", "猫陛下", "男神"],
};

console.log("zhangshan", zhangshan.commonfriends);
// zhangshan [ '骑驴看海', '大漠上的英雄', '小草' ]

console.log("QQUser.prototype", QQUser.prototype.commonfriends);
// QQUser.prototype [ '海草', '猫陛下', '男神' ]

let yaoguang = new QQUser("摇光", 12, "猫陛下");
console.log("yaoguang", yaoguang.commonfriends);
// yaoguang [ '海草', '猫陛下', '男神' ]

/**
 * zhangshan的原型对象指向还是原来的空间
 * 我们改变的是原型对象的指向空间
 * 从上往下执行，不能改变已经分配好的内存空间
 */
```

### 思考题：`zhangshan.__proto__.show()`和`zhangshan.show()`输出结果完全一样吗？为什么呢
